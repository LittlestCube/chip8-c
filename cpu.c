#include "chip8.h"

unsigned short pc = 0x200;

unsigned char tmp_chip8_fontset[] =
{ 
	0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
	0x20, 0x60, 0x20, 0x20, 0x70, // 1
	0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
	0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
	0x90, 0x90, 0xF0, 0x10, 0x10, // 4
	0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
	0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
	0xF0, 0x10, 0x20, 0x40, 0x40, // 7
	0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
	0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
	0xF0, 0x90, 0xF0, 0x90, 0x90, // A
	0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
	0xF0, 0x80, 0x80, 0x80, 0xF0, // C
	0xE0, 0x90, 0x90, 0x90, 0xE0, // D
	0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
	0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

void initCPU()
{
	for (int i = 0; i < 80; i++)
	{
		memory[i] = tmp_chip8_fontset[i];
	}
}

void nextOp()
{
	pc += 2;	// add 2 to program counter (as opcodes are two bytes long)
}

void msleep(long millisec)
{
	struct timespec ts;
	
	ts.tv_sec = millisec / 1000;
	ts.tv_nsec = (millisec % 1000) * 1000000;
	
	nanosleep(&ts, &ts);
}

void cycle()
{
	if (pc <= 4095 && pc >= 0)
	{
		opcode = (short) ((memory[pc] << (short) 8) | memory[pc + 1]);
	}
	
	else
	{
		printf("pc out of bounds, closing...");
		exit(1);
	}
	
	printf("opcode: 0x%X\t\tpc: 0x%X\n", opcode, pc);
	
	switch (opcode & 0xF000)
	{
		case 0x0000:
		{
			switch (opcode & 0x00FF)
			{
				case 0x00E0:	// 0x00E0: clears the screen
				{
					displayClear();
					
					nextOp();
				}
			}
		}
	}
}